package main

import "math"

// 方法二：优化的动态规划
// 复杂度分析
//
// 时间复杂度：O(n)，其中 nnn 是给定的正整数。和方法一相比，计算每个整数对应的 dp 的值的时间复杂度降到 O(1)，因此总时间复杂度降到 O(n)。
//
// 空间复杂度：O(n)，其中 nnn 是给定的正整数。创建一个数组 dp，其长度为 n+1n+1n+1。
// 作者：力扣官方题解
// 链接：https://leetcode.cn/problems/integer-break/solutions/352875/zheng-shu-chai-fen-by-leetcode-solution/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
func leetcode2(n int) int {
	if n <= 3 {
		return n - 1
	}
	dp := make([]int, n+1)
	dp[2] = 1
	for i := 3; i <= n; i++ {
		dp[i] = max(max(2*(i-2), 2*dp[i-2]), max(3*(i-3), 3*dp[i-3]))
	}
	return dp[n]
}

// 方法三：数学
// 方法二中利用了数学知识降低时间复杂度。正整数 4 可以拆分成 2+2，乘积不变（4=2×2）。
// 对于大于 4 的正整数，总是存在一种拆分的方案，使得拆分成的两个正整数的乘积大于拆分前的正整数（例如，5=2+3，2×3=6>5）。
// 那么，能否利用数学知识在方法二的基础上进一步降低时间复杂度，找到最优的拆分方案呢？
//
// 归纳证明法
//
// 第一步：证明最优的拆分方案中不会出现大于 4 的整数。
// 假设出现了大于 4 的整数 x，由于 2(x−2)>x 在 x>4 时恒成立，将 x 拆分成 2 和 x−2 可以增大乘积。
// 因此最优的拆分方案中不会出现大于 4 的整数。
//
// 第二步：证明最优的拆分方案中可以不出现整数 4。
// 如果出现了整数 4，我们可以用 2×2 代替之，乘积不变。
//
// 此时，我们可以知道，最优的拆分方案中只会出现 1，2 和 3。
//
// 第三步：证明当 n≥5 时，最优的拆分方案中不会出现整数 1。
// 当 n≥5 时，如果出现了整数 1，那么拆分中剩余的数的和为 n−1≥4，对应这至少两个整数。
// 我们将其中任意一个整数 x 加上 1，乘积就会增大。因此最优的拆分方案中不会出现整数 1。
//
// 此时，我们可以知道，当 n≥5 时，最优的拆分方案中只会出现 2 和 3。
//
// 第四步：证明当 n≥5 时，最优的拆分方案中 2 的个数不会超过 3 个。
// 如果出现了超过 3 个 2，那么将它们转换成 2 个 3，可以增大乘积，即 3×3>2×2。
//
// 此时，n≥ 的最优拆分方案就唯一了。这是因为当最优的拆分方案中 2 的个数分别为 0，1，2 个时，
// 就对应着 n 除以 3 的余数分别为 0，2，1 的情况。因此我们可以得到和「函数极值证明法」相同的分类讨论结果。
//
// 当 n=4 时，4=2×2 的最优拆分方案也可以放入分类讨论结果；当 2≤n≤3 时，只有唯一的拆分方案 1×(n−1)。
//
// 作者：力扣官方题解
// 链接：https://leetcode.cn/problems/integer-break/solutions/352875/zheng-shu-chai-fen-by-leetcode-solution/
// 来源：力扣（LeetCode）
// 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。
func leetcode3(n int) int {
	if n <= 3 {
		return n - 1
	}
	quotient := n / 3
	remainder := n % 3
	if remainder == 0 {
		return int(math.Pow(3, float64(quotient)))
	} else if remainder == 1 {
		return int(math.Pow(3, float64(quotient-1))) * 4
	}
	return int(math.Pow(3, float64(quotient))) * 2
}
