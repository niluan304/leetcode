package main

import "math/bits"

// ## 前置知识：动态规划入门
//
// 请看视频讲解：`b23.tv/pc522x3`
//
// ## 前置知识：从集合论到位运算
//
// 本文会用到如下位运算技巧：
//
// 1. 集合求并
// 2. 集合求差
// 3. lowbit
// 4. 枚举子集
//
// 这些技巧全部收录在 [从集合论到位运算，常见位运算技巧分类总结！](https://leetcode.cn/circle/discuss/CaOJ45/)如果你没看懂代码中的位运算，可以查阅这篇文章，和本文的图解。
//
// ## 一、启发思考：寻找子问题
//
// ![LC1349-1-c.png](https://pic.leetcode.cn/1703494396-tdKdhi-LC1349-1-c.png)
//
// 对于示例 1，我们要解决的问题是：在第三排的座位状态为 $\texttt{#.##.#}$ 的情况下，前三排最多可以坐多少个学生。
//
// 分类讨论：
//
// - 如果第三排没有学生，那么需要解决的问题为：在第二排的座位状态为 $\texttt{.####.}$ 的情况下，前两排最多可以坐多少个学生。
// - 如果第三排的左边有学生，那么需要解决的问题为：在第二排的座位状态为 $\texttt{#####.}$ 的情况下，前两排最多可以坐多少个学生。
// - 如果第三排的右边有学生，那么需要解决的问题为：在第二排的座位状态为 $\texttt{.#####}$ 的情况下，前两排最多可以坐多少个学生。
// - 如果第三排的左右都有学生，那么需要解决的问题为：在第二排的座位状态为 $\texttt{######}$ 的情况下，前两排最多可以坐多少个学生。
//
// 由于这四种情况都会把原问题变成一个**和原问题相似的、规模更小的子问题**，所以可以用**递归**解决。
//
// > 注 1：从下往上思考，主要是为了方便把递归翻译成递推。从上往下思考也是可以的。
// >
// > 注 2：动态规划有「选或不选」和「枚举选哪个」两种基本思考方式。在做题时，可根据题目要求，选择适合题目的一种来思考。本题用到的是「枚举选哪个」。
//
// ## 二、递归怎么写：状态定义与状态转移方程
//
// 因为要解决的问题都形如「在第 x 排的座位状态为 xxx 的情况下，前 x 排最多可以坐多少个学生」，所以定义 $\textit{dfs}(i,j)$ 表示在**第** $i$ 排的座位状态为 $j$ 的情况下，**前** $i$ 排的最大学生数。
//
// $j$ 是什么类型？如果用字符串就太麻烦了。我们可以用二进制数来表示座位状态，即二进制从低到高的第 $k$ 位为 $1$，就表示第 $i$ 排从左到右的第 $k$ 把椅子是可用的，为 $0$ 就表示这把椅子不可用。
//
// 例如 $\texttt{.#..}$ 可以用二进制数 $1101$ 表示，注意二进制数是**从右往左**读的。
//
// 同样地，也可以用二进制数来表示这一排的哪些椅子坐了学生，即二进制从低到高的第 $k$ 位为 $1$，就表示从左到右的第 $k$ 把椅子坐了学生，为 $0$ 就表示这把椅子没有坐学生。
//
// 示例 1 的第三排对应二进制数 $010010$，分类讨论：
//
// - 如果第三排没有学生（$000000$），那么需要解决的问题为：在第二排的座位状态为 $100001$ 的情况下，前两排最多可以坐多少个学生。
// - 如果第三排的左边有学生（$000010$），那么需要解决的问题为：在第二排的座位状态为 $100000$ 的情况下，前两排最多可以坐多少个学生。再次强调，二进制数是**从右往左**读的。
// - 如果第三排的右边有学生（$010000$），那么需要解决的问题为：在第二排的座位状态为 $000001$ 的情况下，前两排最多可以坐多少个学生。
// - 如果第三排的左右都有学生（$010010$），那么需要解决的问题为：在第二排的座位状态为 $000000$ 的情况下，前两排最多可以坐多少个学生。
//
// 把前两排的最大学生个数加上第三排的学生个数，取最大值，就得到了 $\textit{dfs}(i,j)$，即
//
// $$
// \textit{dfs}(i,j) = \max_{s\subseteq j}\{\textit{dfs}(i-1,t) + |s|\}
// $$
//
// 其中：
//
// - $s$ 表示坐在第 $i$ 排的学生，是 $j$ 的子集，且 $s$ 的二进制数中不能有两个 $1$ 是相邻的。判断二进制数中没有两个 $1$ 相邻，可以用 `(s & (s >> 1)) == 0`，如果有两个 $1$ 相邻，那么左边的 $1$ 右移一位后，与右边的 $1$ 的按位与（AND）必然是 $1$。注：写成 `(s & (s << 1)) == 0` 也是可以的。
// - $|s|$ 表示坐在第 $i$ 排的学生个数，即 $s$ 的二进制数中 $1$ 的个数，可以直接调用库函数解决。
// - $t$ 表示第 $i-1$ 排的可用座位，如何计算请看下图。
//
// ![LC1349-2-c.png](https://pic.leetcode.cn/1703497127-DjAzVW-LC1349-2-c.png)
//
// 当第一排的可用座位为 $j$ 时，最多可以坐多少个学生？请看下图。
//
// ![LC1349-3-c.png](https://pic.leetcode.cn/1703496907-NXhkUL-LC1349-3-c.png)
//
// 递归入口：$\textit{dfs}(m-1, a[m-1])$，也就是答案。其中 $a[i]$ 表示第 $i$ 排能坐人的位置。
//
// 作者：灵茶山艾府
// 链接：https://leetcode.cn/problems/maximum-students-taking-exam/solutions/2580043/jiao-ni-yi-bu-bu-si-kao-dong-tai-gui-hua-9y5k/
func endlessCheng(seats [][]byte) int {
	m, n := len(seats), len(seats[0])
	a := make([]int, m) // a[i] 是第 i 排可用椅子的下标集合
	for i, s := range seats {
		for j, c := range s {
			if c == '.' {
				a[i] |= 1 << j
			}
		}
	}

	memo := make([][]int, m)
	for i := range memo {
		memo[i] = make([]int, 1<<n)
		for j := range memo[i] {
			memo[i][j] = -1 // -1 表示没有计算过
		}
	}
	var dfs func(int, int) int
	dfs = func(i, j int) (res int) {
		p := &memo[i][j]
		if *p != -1 { // 之前计算过
			return *p
		}
		defer func() { *p = res }() // 记忆化
		if i == 0 {
			if j == 0 {
				return 0
			}
			lb := j & -j
			return dfs(i, j&^(lb*3)) + 1
		}
		res = dfs(i-1, a[i-1])               // 第 i 排空着
		for s := j; s > 0; s = (s - 1) & j { // 枚举 j 的子集 s
			if s&(s>>1) == 0 { // s 没有连续的 1
				t := a[i-1] & ^(s<<1 | s>>1) // 去掉不能坐人的位置
				res = max(res, dfs(i-1, t)+bits.OnesCount(uint(s)))
			}
		}
		return
	}
	return dfs(m-1, a[m-1])
}

// 用「选或不选」来枚举子集
// 在[【基础算法精讲 20】](https://leetcode.cn/link/?target=https%3A%2F%2Fwww.bilibili.com%2Fvideo%2FBV1ub411Q7sB%2F)中，我讲了求最长递增子序列的四种思路，前两种思路是「选或不选」和「枚举选哪个」，这两种思路是可以互相转换的。
//
// 本文前面讲的做法基于「枚举选哪个」，即枚举子集。事实上，枚举子集也可以用「选或不选」来做，这要如何实现呢？
//
// 前面讲过，在 $i=0$ 的时候，可以用 `j & ~(lb * 3)` 来表示对这一排的单个座位的「选」，这一技巧同样可以应用到 $i>0$ 的情况。
//
// 把 $j$ 当成是「这一排的剩余座位」，但只有 $j$ 的话，就丢失了「前面选了哪些座位」这一信息，所以要多加一个参数 $k$ 表示这一排前面选了哪些座位。
//
// 定义 $dfs(i,j,k)$ 表示在第 $i$ 排的剩余待选座位状态为 $j$，并且已选座位状态为 $k$ 的情况下，前 $i$ 排的最大学生数。
//
// 如果还剩下需要选的座位，即 j>0j>0j>0，我们分类讨论：
//
// 不选，那么去掉最低的 $1$，即 dfs(i, j, k) = dfs(i, j ^ lb, k)。
// 选，那么去掉最低的 $1$，其左边相邻比特置 000，同时把最低的 $1$ 加到 $k$ 中，即 dfs(i, j, k) = dfs(i, j & ~(lb * 3), k | lb) + 1。
// 这两种情况取最大值。
//
// 如果没有需要选的座位，即 $j=0$，那么继续考虑前一排怎么选，从 $a[i−1]$ 中移除不能坐的位置，递归到 `dfs(i - 1, a[i - 1] & ~(k << 1 | k >> 1), 0)`。
//
// 递归边界：$dfs(0,0,k)=0$。
//
// 递归入口：$dfs(m−1,a[m−1],0)$，即答案。
//
// 注：由于状态较为离散，推荐用哈希表记录状态，用 Python 自带的 @cache 写是最舒服的。其它语言的写法请参考 Go 的实现。
func endlessCheng2(seats [][]byte) int {
	m := len(seats)
	a := make([]int, m)
	for i, s := range seats {
		for j, c := range s {
			if c == '.' {
				a[i] |= 1 << j
			}
		}
	}

	memo := map[[3]int]int{}
	var dfs func(int, int, int) int
	dfs = func(i, j, k int) (res int) {
		t := [3]int{i, j, k}
		if v, ok := memo[t]; ok {
			return v
		}
		defer func() { memo[t] = res }()
		if j == 0 {
			if i == 0 {
				return 0
			}
			return dfs(i-1, a[i-1]&^(k<<1|k>>1), 0)
		}
		lb := j & -j
		return max(dfs(i, j^lb, k), dfs(i, j&^(lb*3), k|lb)+1)
	}
	return dfs(m-1, a[m-1], 0)
}
