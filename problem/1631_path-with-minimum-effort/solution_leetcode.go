package main

import "sort"

// #### 前言
//
// 我们可以将本题抽象成如下的一个图论模型：
//
// - 我们将地图中的每一个格子看成图中的一个节点；
//
// - 我么将两个相邻（左右相邻或者上下相邻）的两个格子对应的节点之间连接一条无向边，边的权值为这两个格子的高度差的绝对值；
//
// - 我们需要找到一条从左上角到右下角的**最短**路径，其中一条路径的长度定义为其经过的所有边权的**最大值**。
//
// 由于地图是二维的，我们需要给每个格子对应的节点赋予一个唯一的节点编号。如果地图的行数为 $m$，列数为 $n$，那么位置为 $(i, j)$ 的格子对应的编号为 $i \times n + j$，这样 $,mn$ 个格子的编号一一对应着 $[0, mn)$ 范围内的所有整数。当然，如果读者使用的语言支持对二元组进行哈希计算、作为下标访问等，则不需要这一步操
// 作。
//
// 本篇题解中会介绍三种不同的解决方法。
//
// #### 方法一：二分查找
//
// **思路与算法**
//
// 我们可以将这个问题转化成一个「判定性」问题，即：
//
// > 是否存在一条从左上角到右下角的路径，其经过的所有边权的最大值不超过 $x$？
//
// 这个判定性问题解决起来并不复杂，我们只要从左上角开始进行深度优先搜索或者广度优先搜索，在搜索的过程中只允许经过边权不超过 $x$ 的边，搜索结束后判断是否能到达右下角即可。
//
// 随着 $x$ 的增大，原先可以经过的边仍然会被保留，因此如果当 $x=x_0$ 时，我们可以从左上角到达右下角，那么当 $x > x_0$ 时同样也可以可行的。因此我们可以使用二分查找的方法，找出满足要求的最小的那个 $x$ 值，记为 $x_\textit{ans}$，那么：
//
// - 当 $x < x_\textit{ans}$，我们无法从左上角到达右下角；
//
// - 当 $x \geq x_\textit{ans}$，我们可以从左上角到达右下角。
//
// 由于格子的高度范围为 $[1, 10^6]$，因此我们可以 $[0, 10^6-1]$ 的范围内对 $x$ 进行二分查找。在每一步查找的过程中，我们使用进行深度优先搜索或者广度优先搜索判断是否可以从左上角到达右下角，并根据判定结果更新二分查找的左边界或右边界即可。
// 下面的代码中使用的是广度优先搜索。
//
// **复杂度分析**
//
// - 时间复杂度：$o(mn \\log c)$，其中 $m$ 和 $n$ 分别是地图的行数和列数，$c$ 是格子的最大高度，在本题中 $c$ 不超过 $10^6$。我们需要进行 $o(\\log c)$ 次二分查找，每一步查找的过程中需要使用广度优先搜索，在 $o(mn)$ 的时间判断是否可以从左上角到达右下角，因此总时间复杂度为 $o(mn \\log c)$。
//
// - 空间复杂度：$o(mn)$，即为广度优先搜索中使用的队列需要的空间。
func leetcode1(heights [][]int) int {

	type pair struct{ x, y int }

	var dirs = []pair{{-1, 0}, {1, 0}, {0, -1}, {0, 1}}

	n, m := len(heights), len(heights[0])
	return sort.Search(1e6, func(maxHeightDiff int) bool {
		vis := make([][]bool, n)
		for i := range vis {
			vis[i] = make([]bool, m)
		}
		vis[0][0] = true
		queue := []pair{{}}
		for len(queue) > 0 {
			p := queue[0]
			queue = queue[1:]
			if p.x == n-1 && p.y == m-1 {
				return true
			}
			for _, d := range dirs {
				x, y := p.x+d.x, p.y+d.y
				if 0 <= x && x < n && 0 <= y && y < m && !vis[x][y] && abs(heights[x][y]-heights[p.x][p.y]) <= maxHeightDiff {
					vis[x][y] = true
					queue = append(queue, pair{x, y})
				}
			}
		}
		return false
	})
}
